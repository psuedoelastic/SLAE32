; Filename: execve-stack.nasm
global _start
section .text

_start:

;BUILDING UP THE NULL TERMINATED /bin//sh to be used in EXECVE
;WE CAN ALSO USE OTHER REGISTERS INSTEAD OF EAX
         xor eax,eax          ; zeroing DWORD register so to build the null termination
         push eax             ; pushing the register on the stack
         push 0x68732f2f      ; output from reverse.py "/bin//sh" 8 characters --- hs//
         push 0x6e69622f      ; output from reverse.py "/bin//sh" 8 characters --- nib/
                              ; all these are being referenced by ESP as they are on the top of the stack
         mov ebx, esp         ; so we can load them in EBX
                              ; EBX should hold the null terminated /bin//sh (ie /bin//sh,0x0)
                              ; we choose to load them in EBX, firstly because the first argument of a command goes on EBX and
                              ; secondly because EXECVE's first argument (const char *filename) should be the null terminated file to execute
                              ; which is exactly what we constructed above using the xor-ed and pushed "/bin//sh" on the stack

;BUILDING UP THE THIRD (envp) ARGUMENT OF EXECVE
;char *const envp[] in our case should be null
         push eax             ; EAX is already null from the xor (see further up), we just need to push it on the stack
                              ; so it positions on the top of the stack and be available to be allocated on another register
         mov edx, esp         ; char *const envp[] is the 3rd parameter so it has to be stored in EDX
                              ; essentially ESP holds the zero-ed values from the "push eax"
                              ; and... we copy the top of the stack (zero-ed) into EDX

;BUILDING UP THE SECOND (argv) ARGUMENT OF EXECVE
; char *const argv[] should be "address_of_bin_bash, null (0x00000000)
         push ebx             ; EBX is already on the stack and holds the address where /bin//sh,0x0 begins
         mov ecx, esp         ; then you just need to move the top of the stack to the ECX register

;INVOKING EXECVE SYSCALL NUMBER
         mov al, 11           ; we could also do: mov al,0xb
         int 0x80             ; invoke syscall
